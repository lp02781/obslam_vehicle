// Generated by gencpp from file hehe/lidar.msg
// DO NOT EDIT!


#ifndef HEHE_MESSAGE_LIDAR_H
#define HEHE_MESSAGE_LIDAR_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace hehe
{
template <class ContainerAllocator>
struct lidar_
{
  typedef lidar_<ContainerAllocator> Type;

  lidar_()
    : number(0)
    , angle_min(0.0)
    , angle_max(0.0)
    , angle_inc(0.0)
    , time_inc(0.0)
    , scan_time(0.0)
    , range_min(0.0)
    , range_max(0.0)
    , range_size(0)
    , count(0)
    , countless(0)
    , lidar_ranges_1(0.0)
    , lidar_ranges_2(0.0)
    , lidar_ranges_3(0.0)
    , lidar_ranges_4(0.0)
    , lidar_ranges_5(0.0)
    , lidar_ranges_6(0.0)
    , lidar_ranges_7(0.0)
    , lidar_ranges_8(0.0)
    , lidar_ranges_9(0.0)
    , lidar_ranges_10(0.0)
    , lidar_ranges_11(0.0)
    , lidar_ranges_12(0.0)
    , lidar_ranges_13(0.0)
    , lidar_ranges_14(0.0)
    , lidar_ranges_15(0.0)
    , lidar_ranges_16(0.0)
    , lidar_ranges_17(0.0)
    , lidar_ranges_18(0.0)
    , lidar_ranges_19(0.0)
    , lidar_ranges_20(0.0)
    , lidar_ranges_21(0.0)
    , lidar_ranges_22(0.0)
    , lidar_ranges_23(0.0)
    , lidar_ranges_24(0.0)  {
    }
  lidar_(const ContainerAllocator& _alloc)
    : number(0)
    , angle_min(0.0)
    , angle_max(0.0)
    , angle_inc(0.0)
    , time_inc(0.0)
    , scan_time(0.0)
    , range_min(0.0)
    , range_max(0.0)
    , range_size(0)
    , count(0)
    , countless(0)
    , lidar_ranges_1(0.0)
    , lidar_ranges_2(0.0)
    , lidar_ranges_3(0.0)
    , lidar_ranges_4(0.0)
    , lidar_ranges_5(0.0)
    , lidar_ranges_6(0.0)
    , lidar_ranges_7(0.0)
    , lidar_ranges_8(0.0)
    , lidar_ranges_9(0.0)
    , lidar_ranges_10(0.0)
    , lidar_ranges_11(0.0)
    , lidar_ranges_12(0.0)
    , lidar_ranges_13(0.0)
    , lidar_ranges_14(0.0)
    , lidar_ranges_15(0.0)
    , lidar_ranges_16(0.0)
    , lidar_ranges_17(0.0)
    , lidar_ranges_18(0.0)
    , lidar_ranges_19(0.0)
    , lidar_ranges_20(0.0)
    , lidar_ranges_21(0.0)
    , lidar_ranges_22(0.0)
    , lidar_ranges_23(0.0)
    , lidar_ranges_24(0.0)  {
  (void)_alloc;
    }



   typedef int16_t _number_type;
  _number_type number;

   typedef float _angle_min_type;
  _angle_min_type angle_min;

   typedef float _angle_max_type;
  _angle_max_type angle_max;

   typedef float _angle_inc_type;
  _angle_inc_type angle_inc;

   typedef float _time_inc_type;
  _time_inc_type time_inc;

   typedef float _scan_time_type;
  _scan_time_type scan_time;

   typedef float _range_min_type;
  _range_min_type range_min;

   typedef float _range_max_type;
  _range_max_type range_max;

   typedef int16_t _range_size_type;
  _range_size_type range_size;

   typedef int16_t _count_type;
  _count_type count;

   typedef int16_t _countless_type;
  _countless_type countless;

   typedef float _lidar_ranges_1_type;
  _lidar_ranges_1_type lidar_ranges_1;

   typedef float _lidar_ranges_2_type;
  _lidar_ranges_2_type lidar_ranges_2;

   typedef float _lidar_ranges_3_type;
  _lidar_ranges_3_type lidar_ranges_3;

   typedef float _lidar_ranges_4_type;
  _lidar_ranges_4_type lidar_ranges_4;

   typedef float _lidar_ranges_5_type;
  _lidar_ranges_5_type lidar_ranges_5;

   typedef float _lidar_ranges_6_type;
  _lidar_ranges_6_type lidar_ranges_6;

   typedef float _lidar_ranges_7_type;
  _lidar_ranges_7_type lidar_ranges_7;

   typedef float _lidar_ranges_8_type;
  _lidar_ranges_8_type lidar_ranges_8;

   typedef float _lidar_ranges_9_type;
  _lidar_ranges_9_type lidar_ranges_9;

   typedef float _lidar_ranges_10_type;
  _lidar_ranges_10_type lidar_ranges_10;

   typedef float _lidar_ranges_11_type;
  _lidar_ranges_11_type lidar_ranges_11;

   typedef float _lidar_ranges_12_type;
  _lidar_ranges_12_type lidar_ranges_12;

   typedef float _lidar_ranges_13_type;
  _lidar_ranges_13_type lidar_ranges_13;

   typedef float _lidar_ranges_14_type;
  _lidar_ranges_14_type lidar_ranges_14;

   typedef float _lidar_ranges_15_type;
  _lidar_ranges_15_type lidar_ranges_15;

   typedef float _lidar_ranges_16_type;
  _lidar_ranges_16_type lidar_ranges_16;

   typedef float _lidar_ranges_17_type;
  _lidar_ranges_17_type lidar_ranges_17;

   typedef float _lidar_ranges_18_type;
  _lidar_ranges_18_type lidar_ranges_18;

   typedef float _lidar_ranges_19_type;
  _lidar_ranges_19_type lidar_ranges_19;

   typedef float _lidar_ranges_20_type;
  _lidar_ranges_20_type lidar_ranges_20;

   typedef float _lidar_ranges_21_type;
  _lidar_ranges_21_type lidar_ranges_21;

   typedef float _lidar_ranges_22_type;
  _lidar_ranges_22_type lidar_ranges_22;

   typedef float _lidar_ranges_23_type;
  _lidar_ranges_23_type lidar_ranges_23;

   typedef float _lidar_ranges_24_type;
  _lidar_ranges_24_type lidar_ranges_24;





  typedef boost::shared_ptr< ::hehe::lidar_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hehe::lidar_<ContainerAllocator> const> ConstPtr;

}; // struct lidar_

typedef ::hehe::lidar_<std::allocator<void> > lidar;

typedef boost::shared_ptr< ::hehe::lidar > lidarPtr;
typedef boost::shared_ptr< ::hehe::lidar const> lidarConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::hehe::lidar_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::hehe::lidar_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::hehe::lidar_<ContainerAllocator1> & lhs, const ::hehe::lidar_<ContainerAllocator2> & rhs)
{
  return lhs.number == rhs.number &&
    lhs.angle_min == rhs.angle_min &&
    lhs.angle_max == rhs.angle_max &&
    lhs.angle_inc == rhs.angle_inc &&
    lhs.time_inc == rhs.time_inc &&
    lhs.scan_time == rhs.scan_time &&
    lhs.range_min == rhs.range_min &&
    lhs.range_max == rhs.range_max &&
    lhs.range_size == rhs.range_size &&
    lhs.count == rhs.count &&
    lhs.countless == rhs.countless &&
    lhs.lidar_ranges_1 == rhs.lidar_ranges_1 &&
    lhs.lidar_ranges_2 == rhs.lidar_ranges_2 &&
    lhs.lidar_ranges_3 == rhs.lidar_ranges_3 &&
    lhs.lidar_ranges_4 == rhs.lidar_ranges_4 &&
    lhs.lidar_ranges_5 == rhs.lidar_ranges_5 &&
    lhs.lidar_ranges_6 == rhs.lidar_ranges_6 &&
    lhs.lidar_ranges_7 == rhs.lidar_ranges_7 &&
    lhs.lidar_ranges_8 == rhs.lidar_ranges_8 &&
    lhs.lidar_ranges_9 == rhs.lidar_ranges_9 &&
    lhs.lidar_ranges_10 == rhs.lidar_ranges_10 &&
    lhs.lidar_ranges_11 == rhs.lidar_ranges_11 &&
    lhs.lidar_ranges_12 == rhs.lidar_ranges_12 &&
    lhs.lidar_ranges_13 == rhs.lidar_ranges_13 &&
    lhs.lidar_ranges_14 == rhs.lidar_ranges_14 &&
    lhs.lidar_ranges_15 == rhs.lidar_ranges_15 &&
    lhs.lidar_ranges_16 == rhs.lidar_ranges_16 &&
    lhs.lidar_ranges_17 == rhs.lidar_ranges_17 &&
    lhs.lidar_ranges_18 == rhs.lidar_ranges_18 &&
    lhs.lidar_ranges_19 == rhs.lidar_ranges_19 &&
    lhs.lidar_ranges_20 == rhs.lidar_ranges_20 &&
    lhs.lidar_ranges_21 == rhs.lidar_ranges_21 &&
    lhs.lidar_ranges_22 == rhs.lidar_ranges_22 &&
    lhs.lidar_ranges_23 == rhs.lidar_ranges_23 &&
    lhs.lidar_ranges_24 == rhs.lidar_ranges_24;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::hehe::lidar_<ContainerAllocator1> & lhs, const ::hehe::lidar_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace hehe

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::hehe::lidar_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hehe::lidar_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hehe::lidar_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hehe::lidar_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hehe::lidar_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hehe::lidar_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::hehe::lidar_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c5f50167c14b9c625c4d23ea090650d0";
  }

  static const char* value(const ::hehe::lidar_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc5f50167c14b9c62ULL;
  static const uint64_t static_value2 = 0x5c4d23ea090650d0ULL;
};

template<class ContainerAllocator>
struct DataType< ::hehe::lidar_<ContainerAllocator> >
{
  static const char* value()
  {
    return "hehe/lidar";
  }

  static const char* value(const ::hehe::lidar_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::hehe::lidar_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int16 number\n"
"float32 angle_min\n"
"float32 angle_max\n"
"float32 angle_inc\n"
"float32 time_inc\n"
"float32 scan_time\n"
"float32 range_min\n"
"float32 range_max\n"
"int16 range_size\n"
"int16 count\n"
"int16 countless\n"
"float32 lidar_ranges_1\n"
"float32 lidar_ranges_2\n"
"float32 lidar_ranges_3\n"
"float32 lidar_ranges_4\n"
"float32 lidar_ranges_5\n"
"float32 lidar_ranges_6\n"
"float32 lidar_ranges_7\n"
"float32 lidar_ranges_8\n"
"float32 lidar_ranges_9\n"
"float32 lidar_ranges_10\n"
"float32 lidar_ranges_11\n"
"float32 lidar_ranges_12\n"
"float32 lidar_ranges_13\n"
"float32 lidar_ranges_14\n"
"float32 lidar_ranges_15\n"
"float32 lidar_ranges_16\n"
"float32 lidar_ranges_17\n"
"float32 lidar_ranges_18\n"
"float32 lidar_ranges_19\n"
"float32 lidar_ranges_20\n"
"float32 lidar_ranges_21\n"
"float32 lidar_ranges_22\n"
"float32 lidar_ranges_23\n"
"float32 lidar_ranges_24\n"
"\n"
;
  }

  static const char* value(const ::hehe::lidar_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::hehe::lidar_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.number);
      stream.next(m.angle_min);
      stream.next(m.angle_max);
      stream.next(m.angle_inc);
      stream.next(m.time_inc);
      stream.next(m.scan_time);
      stream.next(m.range_min);
      stream.next(m.range_max);
      stream.next(m.range_size);
      stream.next(m.count);
      stream.next(m.countless);
      stream.next(m.lidar_ranges_1);
      stream.next(m.lidar_ranges_2);
      stream.next(m.lidar_ranges_3);
      stream.next(m.lidar_ranges_4);
      stream.next(m.lidar_ranges_5);
      stream.next(m.lidar_ranges_6);
      stream.next(m.lidar_ranges_7);
      stream.next(m.lidar_ranges_8);
      stream.next(m.lidar_ranges_9);
      stream.next(m.lidar_ranges_10);
      stream.next(m.lidar_ranges_11);
      stream.next(m.lidar_ranges_12);
      stream.next(m.lidar_ranges_13);
      stream.next(m.lidar_ranges_14);
      stream.next(m.lidar_ranges_15);
      stream.next(m.lidar_ranges_16);
      stream.next(m.lidar_ranges_17);
      stream.next(m.lidar_ranges_18);
      stream.next(m.lidar_ranges_19);
      stream.next(m.lidar_ranges_20);
      stream.next(m.lidar_ranges_21);
      stream.next(m.lidar_ranges_22);
      stream.next(m.lidar_ranges_23);
      stream.next(m.lidar_ranges_24);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct lidar_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hehe::lidar_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::hehe::lidar_<ContainerAllocator>& v)
  {
    s << indent << "number: ";
    Printer<int16_t>::stream(s, indent + "  ", v.number);
    s << indent << "angle_min: ";
    Printer<float>::stream(s, indent + "  ", v.angle_min);
    s << indent << "angle_max: ";
    Printer<float>::stream(s, indent + "  ", v.angle_max);
    s << indent << "angle_inc: ";
    Printer<float>::stream(s, indent + "  ", v.angle_inc);
    s << indent << "time_inc: ";
    Printer<float>::stream(s, indent + "  ", v.time_inc);
    s << indent << "scan_time: ";
    Printer<float>::stream(s, indent + "  ", v.scan_time);
    s << indent << "range_min: ";
    Printer<float>::stream(s, indent + "  ", v.range_min);
    s << indent << "range_max: ";
    Printer<float>::stream(s, indent + "  ", v.range_max);
    s << indent << "range_size: ";
    Printer<int16_t>::stream(s, indent + "  ", v.range_size);
    s << indent << "count: ";
    Printer<int16_t>::stream(s, indent + "  ", v.count);
    s << indent << "countless: ";
    Printer<int16_t>::stream(s, indent + "  ", v.countless);
    s << indent << "lidar_ranges_1: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_1);
    s << indent << "lidar_ranges_2: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_2);
    s << indent << "lidar_ranges_3: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_3);
    s << indent << "lidar_ranges_4: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_4);
    s << indent << "lidar_ranges_5: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_5);
    s << indent << "lidar_ranges_6: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_6);
    s << indent << "lidar_ranges_7: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_7);
    s << indent << "lidar_ranges_8: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_8);
    s << indent << "lidar_ranges_9: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_9);
    s << indent << "lidar_ranges_10: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_10);
    s << indent << "lidar_ranges_11: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_11);
    s << indent << "lidar_ranges_12: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_12);
    s << indent << "lidar_ranges_13: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_13);
    s << indent << "lidar_ranges_14: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_14);
    s << indent << "lidar_ranges_15: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_15);
    s << indent << "lidar_ranges_16: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_16);
    s << indent << "lidar_ranges_17: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_17);
    s << indent << "lidar_ranges_18: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_18);
    s << indent << "lidar_ranges_19: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_19);
    s << indent << "lidar_ranges_20: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_20);
    s << indent << "lidar_ranges_21: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_21);
    s << indent << "lidar_ranges_22: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_22);
    s << indent << "lidar_ranges_23: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_23);
    s << indent << "lidar_ranges_24: ";
    Printer<float>::stream(s, indent + "  ", v.lidar_ranges_24);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HEHE_MESSAGE_LIDAR_H
